\section{The LWE-Based Cryptosystem}\label{sec:lwe}
Now we introduce the Learning With Errors (LWE)-based cryptosystem
first proposed by Regev in [2]. We first describe the LWE problem.
The problem has integer parameters $n$, $m$, and $q$. It also
uses a probability distribution $\chi$ on $\mathbb{Z}_q$, which is
usually a `rounded' normal distribution centered at 0 where the
sample is rounded to the nearest integer.
The problem's inputs are a matrix $\v{A} \in \mathbb{Z}_q^{m \times n}$
whose elements are chosen uniformly and indepentently from $\mathbb{Z}_q$
and a vector $\v{v}$ either (unknown to the problem solver) chosen
uniformly from $\mathbb{Z}_q^m$ or as $\v{v} = \v{A}\v{s} + \v{e}$
for uniformly chosen $\v{s} \in \mathbb{Z}_q^n$ and $\v{e} \in \mathbb{Z}_q^m$ sampled from $\chi^m$. Solving the problem then consists of determining
which of these two methods was used to generate $\v{v}$.

The initial connection between this problem and lattice problems is that
the case when $\v{v} = \v{A}\v{s} + \v{e}$ is equivalent to choosing
$\v{v}$ as a random point in the lattice $\Lambda_q(\v{A}^T)$ and then
randomly perturbing each of the point's coordinates using $\chi^m$.

A deeper connection is established by a theorem proven in [2] and 
restated in [1]. Both this theorem and the following LWE-based
cryptosystem use the probability distribution $\Psi_{\alpha}$ on $\mathbb{Z}_q$
defined as a normal distribution with mean 0 and standard deviation
$\frac{\alpha q}{\sqrt{2\pi}}$ rounded to the nearest integer and
reduced mod $q$.
The theorem states that if we have an oracle that 
solves the LWE problem using distribution $\Psi_{\alpha}$ and parameters
$n$, $m$, and $q$ with $\alpha q > \sqrt{n}$, $q$ prime and $q$ and $m$
smaller but not exponentially smaller than $n$, then there is a polynomial-time (in $n$) quantum algorithm that can solve reasonably-sized worst-case
SVP and SIVP problems in any $n$-dimensional lattice. (I'd like to give
at least an outline of the proof of this theorem in the final draft).\\

Now we can discussed the LWE-based cryptosystem proposed by [2]. [3] created a
more efficient version of the cryptosystem, which is what [1] presents
and what we will discuss here.

The system has integer parameters $n$, $m$, $l$, $t$, $r$, and $q$, where $n$ is the size of the lattice underlying the system (and is thus
the most important security parameter), $l$ is the length of each message, and
$t$ is the size of the field over which the message bits are chosen (usually 2).
It also has real-valued parameter $\alpha > 0$, which is the spread of
the distribution $\Psi_{\alpha}$.

The system uses function $f: \mathbb{Z}_t^l \to \mathbb{Z}_q^l$ that converts
mod-$t$ vectors to mod-$q$ vectors by multiplying each coordinate in its
input by $\frac{q}{t}$ and rounding to the nearest integer.
$f$ has corresponding inverse $f^{-1}: \mathbb{Z}_q^l \to \mathbb{Z}_t^l$
that converts mod-$q$ vectors to mod-$t$ vectors by multiplying each
coordinate by $\frac{t}{q}$ and rounding to the nearest integer.

The private key is a random uniformly-chosen matrix
$\v{S} \in \mathbb{Z}_q^{n \times l}$. 
To determine a public key, choose two more random matrices:
$\v{A} \in \mathbb{Z}_q^{m \times n}$ from a uniform distribution
and $\v{E} \in \mathbb{Z}_q^{m \times l}$ with each entry chosen
from $\Psi_{\alpha}$. Then calculate 
\begin{equation}
    \v{P} = \v{AS} + \v{E} \in \mathbb{Z}_q^{m \times l} 
\end{equation}
and the public key is the pair $(\v{A}, \v{P})$.

To encrypt a message $\v{v} \in \mathbb{Z}_t^l$ choose $\v{a} \in \{-r, -r+1, \cdots, r\}^m$ uniformly at random, calculate 
\begin{equation}
    \v{u} = \v{A}^T\v{a} \in \mathbb{Z}_q^n,\quad
    \v{c} = \v{P}^T\v{a} + f(\v{v}) \in \mathbb{Z}_q^l
\end{equation}
and send ciphertext $(\v{u}, \v{c})$.

Then to decrypt a ciphertext, calculate 
\begin{equation}
    m = f^{-1}(\v{c} - \v{S}^T\v{u}) \in \mathbb{Z}_t^l
\end{equation}
and $m$ should be the original plaintext.\\

[2] and [3] prove that this system is secure against known plaintext
attacks given the right choice of parameters. They first show that
determining whether the public key $(\v{A}, \v{P})$ was generated
by the cryptosystem using $\Psi_{\alpha}$ or uniformly at random
is equivalent to solving a LWE problem. They then show that if one could
gain information using a known plaintext attack, then they would be able
to distinguish between uniformly randomly generated public keys and
public keys generated by the cryptosystem, so they could solve LWE, 
which is a hard problem (this is another proof I want to read thoroughly
and present here in a more detailed form).

\subsection{Implementation}
\autoref{sec:appendix} (the Appendix) contains a rough Python implementation
of this cryptosystem. The method \verb|send_ciphertext| takes a message
as a text string, converts the text string to a binary string using
ASCII codes, encrypts the binary string in chunks using the above procedure, and outputs the
encrypted chunks. Then \verb|decrypt_ciphertext| decrypts the ciphertexts, converts them back from binary strings to text strings, and outputs
the result. The rounding carried out by the functions $f$ and $f^{-1}$
used in the encryption and decryption procedures occasionally produces
errors and causes the decrypted message not to match the original plaintext.
Thus the program uses a simple Hamming error correcting code to correct at
most one incorrect bit per message (another thing I'd like to change is to implement a more sophisticated error correcting code that can catch
more than one error, because some still show up even though I'm using
a fairly short message length). 
